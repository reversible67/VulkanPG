#version 460

layout (local_size_x = 16, local_size_y = 16) in;

#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "gmm.glsl"
#include "concentric.glsl"

layout (push_constant, scalar) uniform PushConstants
{
	int modelIndex;
	vec3 gridBegin;
	ivec3 gridDim;
	float cellSize;
	int lobeCount;
	float exponentialFactor;
};

layout (binding = 2, scalar) buffer GMMStatisticsPack0 { vec4 gmmStatisticsPack0[]; };
layout (binding = 3, scalar) buffer GMMStatisticsPack1 { vec4 gmmStatisticsPack1[]; };
layout (binding = 4, scalar) buffer readonly VPLs { vec4 vpls[]; };
layout (binding = 5) uniform sampler2D samplerPosition;
layout (binding = 6) uniform sampler2D samplerNormal;

shared vec4 localVPLs[20][20];
//shared vec4 localGeometry[20][20];

bool validate(uvec2 index, uvec2 resolution)
{
    return all(greaterThanEqual(index, uvec2(0))) && all(lessThan(index, resolution));
}

void main()
{
	uvec2 pixel = gl_GlobalInvocationID.xy;
	uvec2 group = gl_LocalInvocationID.xy;

	uvec2 resolution = textureSize(samplerNormal, 0);

	// First load 20 x 20 the vpls into shared memory
	// The offset indicate the left-top element position
	uvec2 offset = gl_WorkGroupID.xy * 16 - 2;
	if (gl_LocalInvocationIndex < 200)
	{
		uvec2 flatten = uvec2(gl_LocalInvocationIndex % 20, gl_LocalInvocationIndex / 20);
		{
			// First half of the group
			uvec2 index_0 = offset + flatten;
			vec4 vpl_0 = validate(index_0, resolution) ? vpls[index_0.y * resolution.x + index_0.x] : vec4(0.0);
			//vec4 geometry_0 = vec4(0.0);
			//if (validate(index_0))
			//{
			//	const ShadingSurface surface = GetGBufferSurface(index_0, globalUniform.cameraData);
			//	geometry_0 = float4(surface.geometryNormal, surface.viewDepth);
			//}
			localVPLs[flatten.x][flatten.y] = vpl_0;
			//localGeometry[flatten.x][flatten.y] = geometry_0;
		}
		{
			// Second half of the group
			uvec2 index_1 = offset + flatten + uvec2(0, 10);
			vec4 vpl_1 = validate(index_1, resolution) ? vpls[index_1.y * resolution.x + index_1.x] : vec4(0.0);
			//vec4 geometry_1 = vec4(0.0);
			//if (validate(index_1))
			//{
			//	const ShadingSurface surface = GetGBufferSurface(index_1, globalUniform.cameraData);
			//	geometry_1 = float4(surface.geometryNormal, surface.viewDepth);
			//}
			localVPLs[flatten.x][flatten.y + 10] = vpl_1;
			//localGeometry[flatten.x][flatten.y] = geometry_1;
		}
	}
    
	memoryBarrierShared();

	uvec2 center_xy = group + uvec2(2);
	vec3 position = texelFetch(samplerPosition, ivec2(pixel), 0).xyz;
	vec3 normal = texelFetch(samplerPosition, ivec2(pixel), 0).xyz;
	//const ShadingSurface center_surface = GetGBufferSurface(pixel, globalUniform.cameraData);
	//if (!IsShadingSurfaceValid(center_surface))
	//	return;

	uint lobeIndex = (pixel.y * resolution.x + pixel.x) * lobeCount;

	GMM2D gmm;
	gmm.epoch_cap = 20;
	for (int i = 0; i < lobeCount; ++i)
	{
		gmm.sufficientStats0[i] = gmmStatisticsPack0[lobeIndex + i];
		gmm.sufficientStats1[i] = gmmStatisticsPack1[lobeIndex + i];
	}
	buildGMMs(gmm);

	mat3 frame = createFrame(normal);

	// First, load the center vpls.
	vec4 center_vpl = localVPLs[center_xy.x][center_xy.y];
	vec3 direction = normalize(center_vpl.xyz - position);
	vec2 square_coord = fromConcentricMap(uniformHemisphereToConcentricDisk(to_local(frame, direction)));

	float pdf[4];
	float denom = 0.0;
	vec2 x = vec2(0.0);
	for (int h = 0; h < 4; ++h)
	{
		pdf[h] = responsibility(gmm, h, x);
		denom += pdf[h];
	}

	stepwiseEM(gmm, center_vpl.w, square_coord, exponentialFactor);

	for (int i = 0; i < lobeCount; ++i)
	{
		gmmStatisticsPack0[lobeIndex + i] = gmm.sufficientStats0[i];
		gmmStatisticsPack1[lobeIndex + i] = gmm.sufficientStats1[i];
	}
}